# ローカルの開発環境のセットアップ

## DBにスキーマとテーブルを作成
```
export DATABASE_URL=postgres://postgres:example@db/ccs_db
sea-orm-cli migrate up
```

## 環境変数の用意
sample.envファイルを.envへリネームし、環境にあった変数を設定する

# DBのテーブルの変更と反映

## DBのテーブルを変更
migration/src以下のソースコードを変更する。その後、下記のコマンドを実行する
```
export DATABASE_URL=postgres://postgres:example@db/ccs_db
sea-orm-cli migrate refresh
```

## 変更されたテーブルをentity以下のソースコードに反映
```
export DATABASE_URL=postgres://postgres:example@db/ccs_db
sea-orm-cli generate entity -s ccs_schema -o entity/src
```

# DBのテーブル設計方針

## トランザクション分離レベルは、PostgreSQLのデフォルト（READ COMMITTED）を想定して設計

## 外部キー採用時の検討事項
外部キーを採用するときは、下記の事項を検討し、課題がないことを明確にした上で採用する
### パーティション化できなくなる
多くのDBでは、外部キーで関連付けたテーブルはパーティション化できなくなる。本プロジェクトで利用しているPostgreSQLも同様
### 暗黙的ロックの発生を許容できる（アプリケーションコードに明示的にロックを取得するコードが出てこないことが許容できる）
子のテーブルにinsertやupdateをかけたとき、親のテーブルの対応するレコードに対し、暗黙的に共有ロックがかかる（子テーブルに対するinsertやupdateしかコード上には出てこない）
### 外部キーのカラムに対してインデックス作成が許容できる
親テーブルのレコードの更新、削除で自動的に子テーブルのレコードの更新、削除が発生した場合、子テーブルの外部キーにインデックスがないと親テーブルの１レコードの操作に対して想定以上に遅い操作が発生する可能性がある。そのため、インデックスの作成が許容できる（インデックス再作成が少ない＝頻繁に値の更新がない）カラムであることを確認
### 親テーブルのレコードの更新に対して、子テーブルの更新が許容可能な時間内に操作が完了することを保証できる
ON DELETE CASCADE、ON DELETE SET NULL、ON UPDATE CASCADE、ON UPDATE SET NULLは、親テーブルの対応するレコードが更新されると自動的に子テーブルの更新がかかる（アプリケーションでは制御できない）そのため、親テーブルのレコードに紐づく子テーブルのレコードが無数に存在する場合、子テーブルの更新処理に多大な時間が費やされる可能性がある

[リンクテスト](##外部キー採用時の検討事項)