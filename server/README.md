# ローカルの開発環境のセットアップ

## DBにスキーマとテーブルを作成
```
export DATABASE_URL=postgres://postgres:example@db/ccs_db
sea-orm-cli migrate up
```

## 環境変数の用意
sample.envファイルを.envへリネームし、環境にあった変数を設定する

# DBのテーブルの変更と反映

## DBのテーブルを変更
migration/src以下のソースコードを変更する。その後、下記のコマンドを実行する
```
export DATABASE_URL=postgres://postgres:example@db/ccs_db
sea-orm-cli migrate refresh
```

## 変更されたテーブルをentity以下のソースコードに反映
```
export DATABASE_URL=postgres://postgres:example@db/ccs_db
sea-orm-cli generate entity -s ccs_schema -o entity/src
```

# DBのテーブル設計方針

## トランザクション分離レベル
PostgreSQLのデフォルト（READ COMMITTED）を想定して設計。SERIALIZABLEではないので、トランザクション中でもアプリケーションで明示的なロック取得が必要なことを念頭に置く

## 外部キー採用時の検討事項
外部キーを採用するときは、下記の事項を検討し、課題がないことを明確にした上で採用する
### パーティション化できなくなる
多くのDBでは、外部キーで関連付けたテーブルはパーティション化できなくなる。本プロジェクトで利用しているPostgreSQLも同様
### 暗黙的ロックの発生を許容できる（アプリケーションコードに明示的にロックを取得するコードが出てこないことが許容できる）
子テーブルにinsertやupdateをかけたとき、親テーブルの対応するレコードに対し、暗黙的に共有ロックがかかる（アプリケーションコード上には子テーブルに対するinsertやupdateしか出てこない）
### 外部キーのカラムに対してインデックス作成が許容できる
親テーブルのレコードの更新、削除で自動的に子テーブルのレコードの更新、削除が発生した場合、子テーブルの外部キーにインデックスがないと親テーブルの１レコードの操作に対して想定以上に遅い操作が発生する可能性がある。そのため、インデックスの作成が許容できる（インデックス再作成が少ない＝頻繁に値の更新がない）カラムであることを確認する
### 親テーブルのレコードの更新に対して、子テーブルの更新が許容可能な時間内に操作が完了することを保証できる
ON DELETE CASCADE、ON DELETE SET NULL、ON UPDATE CASCADE、ON UPDATE SET NULLは、親テーブルの対応するレコードが更新されると自動的に子テーブルの更新がかかる（アプリケーションでは制御できない）そのため、親テーブルのレコードに紐づく子テーブルのレコードが無数に存在する場合、子テーブルの更新処理に多大な時間が費やされる可能性がある
### 親子テーブル間で、外部キーで常に整合性を保つ必要があるほど強力な制約が必要か再考する
親テーブルのレコードが削除された場合を考える。子テーブルのレコードが、親テーブルを通してのみしかアクセスされない設計の場合、親テーブルのレコードが削除された時点で該当の子テーブルのレコードには既にアクセスできない。そのため、必ずしも同時に子テーブルのレコードを削除する必要はない。ここで説明するケースにおいては、バッチ処理で非同期的に子テーブルのレコードを削除すれば十分と考えられる

## ユーザー情報を扱う際の注意事項
ユーザーが利用する情報（ユーザー情報、職務経歴、相談料等々（※））は、user_accountテーブルを親として扱い、関連付けたテーブルを作成する。関連付ける際は、外部キーは使わない（参考：[外部キー採用時の検討事項](#外部キー採用時の検討事項)）user_accountテーブルからユーザーが削除された際、関連づいていた子テーブルのレコードは、非同期的にバッチ処理で削除する（削除の際はuser_accountテーブルからdeleted_user_accountテーブルへレコードを移動する。バッチ処理はdeleted_user_accountテーブルへレコードを読み取り、不要に成った子テーブルのレコード（※）を削除する）これの処理を考慮し、子テーブル -> user_accountテーブルの順序のデータの読み書きの流れを設計しないようにする。

（※）関連するテーブルの中でもユーザーが利用する情報のみ削除し、管理者が記録のために必要とするテーブルのデータは削除対象外とする（例えば、利用規約に同意したことを記録するテーブルは削除しない）

## トランザクション内におけるロックの取得順序
デッドロックとなる設計を避けるため、トランザクション内で複数ロックを取得する場合、取得するロックについてこのセクションに明記する
